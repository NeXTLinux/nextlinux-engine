#!/usr/bin/env bash

set -euvo pipefail

COMMIT_SHA="${1:?'Missing required parameter: COMMIT_SHA'}"
GIT_TAG="${2:?'Missing required parameter: GIT_TAG'}"
TEST_IMAGE_NAME="${3:?'Missing required parameter: TEST_IMAGE_NAME'}"
CLI_REPO="${4:?'Missing required parameter: CLI_REPO'}"

# Optional - only used for print_colorized
source nextlinux-ci/utils

# Get the latest nextlinux-cli tag from remote
if [[ "${GIT_TAG}" =~ ^v[0-9]+(\.[0-9]+)*.*$ ]]; then
    nextlinux_cli_commit="$(git -c 'versionsort.suffix=-' ls-remote --exit-code --tags --refs --sort="v:refname" ${CLI_REPO} 'v*' | tail -n1 | sed 's/.*\///')"
# Or, get commit SHA from HEAD of master nextlinux-cli remote
else
    nextlinux_cli_commit="$(git ls-remote ${CLI_REPO} master | cut -f 1)"
fi

print_colorized INFO "Building Nextlinux Engine image ${TEST_IMAGE_NAME}; installing nextlinux-cli from git@${nextlinux_cli_commit}."; echo

# A targeted build can be used to populate the cache in circleci if you're using the docker_layer_caching option in the job.
# Since we're not using docker_layer_caching, this build step can be ignored.
# docker build --target nextlinux-engine-builder -t nextlinux-engine:builder -f ./Dockerfile .

docker build --build-arg NEXTLINUX_COMMIT="${COMMIT_SHA}" --build-arg CLI_COMMIT="${nextlinux_cli_commit}" -t "${TEST_IMAGE_NAME}" -f ./Dockerfile .

print_colorized INFO "Built Nextlinux Engine image ${TEST_IMAGE_NAME}."; echo
